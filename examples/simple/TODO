
**** Layers
	* Un shader/une passe par process
	* Selection
	* CPU/GPU
	* Cible pour l'outil brosse:
		(texture+pipeline)

	Layers VS processes? Idem

	Interface:
		- draw(Texture, Rect)

	Contraintes pour un shader de layer:
		#include "layer.hpp"
		main => layerMain(in image2D source, in image2D mask) 

	* Special layers

Différence entre:
- process
	formule de rendu d'un pixel
	i.e. fonction f(x,y,ldotn,ao,...) -> RGB
	ils peuvent être superposés à l'aide de layers (blending)

	un même process peut être lié à différents paramètres
	i.e. Blur 2D lié:
		- à L.N
		- à la position (XY) 

- layers
	associé à un process

- g-buffers/parameter maps


**** Camera move
	Save camera parameters

* chargement d'un mesh depuis un fichier

* remove tool enum
	* dynamically add tools to the UI

* Layer masks


* Load / save


* Undo list

* Tools and brushes

* Better UI toolkit 
	* more practical
	* extendable by tools
	* declarative (data binding)
	* less barriers to modification

* Better input events
	* It is particularly badly designed (must modify 8 different locations to add a new event type)
	* Fusionner les différents types d'events?

* Separate rendering from event handling
	* rendering must happen during a specific period

* Redraw scene only if parameters have changed
	=> Observables for scene parameters
		* camera
		* light position

* pour les effets non portés par la géométrie: distance fields
ex: glow
	DF: distance aux aplats d'une certaine intensité 
	calcul en temps réel?
ex: shading:
	DF à la shadow shape?
	f(distance) -> intensité

* multi-parameter mapping 

* afficher une grille ou des axes


* Ne pas utiliser des observers avec [this] dans la lambda capture
	=> crash quand l'objet est déplacé

* Trouver une meilleure solution pour les observables avec états
	


Path getBrushPath(coro, ...) 
{
	position = (await(coro, mouseDown.filter(...))).position;
	while (!(await(...))) {

	}
}

mouseDown.subscribe([]{ mouseDown.unsubscribe(), mouseUp.subscribe([](){  }) })


event streams:

Input:
mouse move: event stream
mouse buttons: event stream

stylus touch events: event stream (changes in absolute positions and pressure)
stylus proximity events: event stream (enter, touch, leave)

VS 
single event stream with variants

VS
base class input_event
	- type (derived class) 

input_event
	+ mouse_event
		+ mouse_button_event(button, status)
		+ mouse_move_event(dx, dy)
	+ key_event
	+ stylus_event
		+ stylus_proximity_event
		+ stylus_properties_event

Input class: only one event stream
	observable<input_event_ptr>



UI:
mouse position: signal
mouse button states: signal
stylus last position: signal
stylus state: signal (hovering, touching, out of range)

Painter UI:
pointer position: signal
	(merged mouse+stylus)

mouse position (position): signal

mouse button state(button index): signal

mouse move (raw data): event stream
mouse click: event stream

